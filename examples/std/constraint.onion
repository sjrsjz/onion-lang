@include "prototype.onion";
Float := (v?) -> typeof v == 'Float';
Integer := (v?) -> typeof v == 'Integer';
String := (v?) -> typeof v == 'String';
Boolean := (v?) -> typeof v == 'Boolean';
Bytes := (v?) -> typeof v == 'Bytes';
Lambda := (v?) -> typeof v == 'Lambda';
LazySet := (v?) -> typeof v == 'LazySet';
Pair := (v?) -> typeof v == 'Pair';
InstructionPackage := (v?) -> typeof v == 'InstructionPackage';
Null := (v?) -> typeof v == 'Null';
Undefined := (v?) -> typeof v == 'Undefined';
Tuple := (v?) -> typeof v == 'Tuple';
Never := (v?) -> false; // Never type cannot be instantiated

Positive := (x?) -> x > 0;
Negative := (x?) -> x < 0;

InstanceOf := (interface?) -> (x?) -> interface.check(x);

Union := (checkers?) -> (v?) -> {
    // Iterate through the passed checker tuple
    i := 0;
    len := lengthof checkers;
    while (i < len) (
        checker := checkers[i];
        // If any checker returns true, the entire Union is true
        if (checker(v)) {
            return true;
        };
        i := i + 1
    );
    // If all checkers return false, the entire Union is false
    return false;
};

Intersection := (checkers?) -> (v?) -> {
    // Iterate through the passed checker tuple
    i := 0;
    len := lengthof checkers;
    while (i < len) (
        checker := checkers[i];
        // If any checker returns false, the entire Intersection is false
        if (not checker(v)) {
            return false;
        };
        i := i + 1
    );
    // If all checkers return true, the entire Intersection is true
    return true;
};

Not := (f?) -> (v?) -> not f(v);