@required 'Modules';
if (not keyof (sync (() -> Modules.Option))()) {
    // Define temporary Option constructor and helper functions
    _Option_Temp_Constructor := mut undefined;
    _Some_Temp_Helper := (v?) -> _Option_Temp_Constructor.new(true : v);
    _None_Temp_Helper := () -> _Option_Temp_Constructor.new(false : undefined);

    // Configure temporary Option constructor
    _Option_Temp_Constructor = {
        @include "result.onion";
        @include "prototype.onion";
        // Interface definition for Option instance
        Option_Interface := interface {
            is_some => () -> keyof keyof self,
            is_none => () -> not keyof keyof self,
            map => (f?) -> {
                if (self.is_some()) {
                    return _Some_Temp_Helper(f(valueof keyof self));
                } else {
                    return _None_Temp_Helper();
                }
            },
            filter => (predicate?) -> {
                if (self.is_some() and predicate(valueof keyof self)) {
                    return _Some_Temp_Helper(valueof keyof self);
                } else {
                    return _None_Temp_Helper();
                }
            },
            unwrap => () -> {
                if (self.is_some()) {
                    return valueof keyof self;
                } else {
                    raise Err("Option is None"); // Use globally cached Err
                }
            },
            unwrap_or => (default?) -> {
                if (self.is_some()) {
                    return valueof keyof self;
                } else {
                    return default;
                }
            },
            unwrap_or_else => (f?) -> {
                if (self.is_some()) {
                    return valueof keyof self;
                } else {
                    return f();
                }
            },
            and_then => (f?) -> {
                if (self.is_some()) {
                    return f(valueof keyof self);
                } else {
                    return _None_Temp_Helper();
                }
            },
            or_else => (f?) -> {
                if (self.is_some()) {
                    return _Option_Temp_Constructor.new(keyof self);
                } else {
                    return f();
                }
            }
        };
        Option_Interface // The result of this block is the interface, used to configure _Option_Temp_Constructor
    };

    // Cache the configured temporary Option constructor
    Modules = Modules + (Option => _Option_Temp_Constructor,);
};

// Assign the cached constructor to global Option
Option := Modules.Option;

// Redefine global Some and None helper functions using the cached global Option constructor
Some := (v?) -> Option.new(true : v);
None := () -> Option.new(false : undefined);
