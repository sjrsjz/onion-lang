// æ•°å­¦å‡½æ•°å¯è§†åŒ–å™¨ - åŠ¨æ€å›¾å½¢ç»˜åˆ¶
@required stdlib;

colors := {
    // å‰æ™¯è‰²
    'black': "\u001b[30m",
    'red': "\u001b[31m",
    'green': "\u001b[32m",
    'yellow': "\u001b[33m",
    'blue': "\u001b[34m",
    'magenta': "\u001b[35m",
    'cyan': "\u001b[36m",
    'white': "\u001b[37m",
    'bright_black': "\u001b[90m",
    'bright_red': "\u001b[91m",
    'bright_green': "\u001b[92m",
    'bright_yellow': "\u001b[93m",
    'bright_blue': "\u001b[94m",
    'bright_magenta': "\u001b[95m",
    'bright_cyan': "\u001b[96m",
    'bright_white': "\u001b[97m",

    // èƒŒæ™¯è‰²
    'bg_black': "\u001b[40m",
    'bg_red': "\u001b[41m",
    'bg_green': "\u001b[42m",
    'bg_yellow': "\u001b[43m",
    'bg_blue': "\u001b[44m",
    'bg_magenta': "\u001b[45m",
    'bg_cyan': "\u001b[46m",
    'bg_white': "\u001b[47m",
    'bg_bright_black': "\u001b[100m",
    'bg_bright_red': "\u001b[101m",
    'bg_bright_green': "\u001b[102m",
    'bg_bright_yellow': "\u001b[103m",
    'bg_bright_blue': "\u001b[104m",
    'bg_bright_magenta': "\u001b[105m",
    'bg_bright_cyan': "\u001b[106m",
    'bg_bright_white': "\u001b[107m",

    // é‡ç½®
    'reset': "\u001b[0m"
};

colorize := (text => "", fg => "white", bg => "bg_black") -> {
    fg_color := colors.{fg};
    bg_color := colors.{bg};
    return fg_color + bg_color + text + colors.reset;
};

width := 120;
height := 40;

// æ•°å­¦å‡½æ•°é›†åˆ
math_functions := {
    'sine': (x?, t?) -> stdlib.math.sin(x + t),
    'cosine': (x?, t?) -> stdlib.math.cos(x + t),
    'wave': (x?, t?) -> stdlib.math.sin(x) * stdlib.math.cos(x + t),
    'pulse': (x?, t?) -> stdlib.math.sin(x * 3.0 + t) * stdlib.math.exp(-x * x / 10.0),
    'spiral': (x?, t?) -> stdlib.math.sin(x + t) * x / 10.0,
    'damped': (x?, t?) -> stdlib.math.sin(x * 2.0 + t) * stdlib.math.exp(-stdlib.math.abs(x) / 5.0)
};

// è·å–å‡½æ•°çš„é¢œè‰²æ˜ å°„
get_function_color := (func_name?) -> {
    color_map := {
        'sine': colors.bright_red,
        'cosine': colors.bright_blue,
        'wave': colors.bright_green,
        'pulse': colors.bright_yellow,
        'spiral': colors.bright_magenta,
        'damped': colors.bright_cyan
    };
    return color_map.{func_name};
};

// ç»˜åˆ¶åæ ‡è½´
draw_axes := (canvas?) -> {
    // Xè½´ (ä¸­é—´)
    y_center := height / 2;
    x := mut 0;
    while (x < width) {
        canvas[y_center][x] = colorize("â”€", "white", "bg_black");
        x = x + 1;
    };
    
    // Yè½´ (ä¸­é—´)
    x_center := width / 2;
    y := mut 0;
    while (y < height) {
        canvas[y][x_center] = colorize("â”‚", "white", "bg_black");
        y = y + 1;
    };
    
    // åŸç‚¹
    canvas[y_center][x_center] = colorize("â”¼", "bright_white", "bg_black");
    
    return canvas;
};

// ç»˜åˆ¶å‡½æ•°æ›²çº¿
plot_function := (canvas?, func_name?, func?, time?) -> {
    color := get_function_color(func_name);
    
    x_pixel := mut 0;
    while (x_pixel < width) {
        // å°†åƒç´ åæ ‡è½¬æ¢ä¸ºæ•°å­¦åæ ‡
        x_math := (x_pixel - width / 2.0) / 10.0;
        
        // è®¡ç®—å‡½æ•°å€¼
        y_math := func(x_math, time);
        
        // å°†æ•°å­¦åæ ‡è½¬æ¢ä¸ºåƒç´ åæ ‡
        y_pixel := height / 2 - stdlib.math.round(y_math * 8.0);
        
        // ç¡®ä¿åœ¨ç”»å¸ƒèŒƒå›´å†…
        if (y_pixel >= 0 and y_pixel < height) {
            // é€‰æ‹©å­—ç¬¦
            char := if (stdlib.math.abs(y_math) > 1.5) {
                "â–ˆ"
            } else if (stdlib.math.abs(y_math) > 1.0) {
                "â–“"
            } else if (stdlib.math.abs(y_math) > 0.5) {
                "â–’"
            } else {
                "â–‘"
            };
            
            canvas[y_pixel][x_pixel] = color + char + colors.reset;
        };
        
        x_pixel = x_pixel + 1;
    };
    
    return canvas;
};

// åˆ›å»ºç©ºç”»å¸ƒ
create_canvas := () -> {
    canvas := mut ();
    y := mut 0;
    while (y < height) {
        row := mut ();
        x := mut 0;
        while (x < width) {
            row = row + (mut " ",);
            x = x + 1;
        };
        canvas = canvas + (row,);
        y = y + 1;
    };
    return canvas;
};

// æ¸²æŸ“ç”»å¸ƒ
render_canvas := (canvas?, frame?, current_functions?) -> {
    // æ¸…å±
    stdlib.io.println("\u001b[2J\u001b[H");
    
    // æ ‡é¢˜
    stdlib.io.println(colorize("ğŸ“Š æ•°å­¦å‡½æ•°å¯è§†åŒ–å™¨ - ç¬¬" + stdlib.types.to_string(frame) + "å¸§ ğŸ“Š", "bright_yellow", "bg_black"));
    
    // æ˜¾ç¤ºå½“å‰ç»˜åˆ¶çš„å‡½æ•°
    func_display := mut "å½“å‰å‡½æ•°: ";
    i := mut 0;
    while (i < lengthof current_functions) {
        func_name := current_functions[i];
        color := get_function_color(func_name);
        func_display = func_display + color + func_name + colors.reset + " ";
        i = i + 1;
    };
    stdlib.io.println(func_display);
    stdlib.io.println("");
    
    // è¾“å‡ºç”»å¸ƒ
    y := mut 0;
    while (y < height) {
        x := mut 0;
        while (x < width) {
            stdlib.io.print(canvas[y][x]);
            x = x + 1;
        };
        stdlib.io.println("");
        y = y + 1;
    };
    
    // è¯´æ˜
    stdlib.io.println("");
    stdlib.io.println(colorize("Xè½´: -6 åˆ° +6 | Yè½´: -5 åˆ° +5", "bright_cyan", "bg_black"));
};

// ä¸»åŠ¨ç”»å¾ªç¯
frame := mut 0;
max_frames := 300;

// å‡½æ•°ç»„åˆåºåˆ—
function_sequences := (
    ("sine",),
    ("cosine",),
    ("sine", "cosine"),
    ("wave",),
    ("pulse",),
    ("spiral",),
    ("damped",),
    ("sine", "wave", "pulse"),
    ("cosine", "spiral", "damped")
);
stdlib.io.println(colorize("æ¬¢è¿ä½¿ç”¨æ•°å­¦å‡½æ•°å¯è§†åŒ–å™¨! ğŸ“ˆ", "bright_green", "bg_black"));
while (frame < max_frames) {
    // æ—¶é—´å‚æ•° (ç”¨äºåŠ¨ç”»)
    time := frame * 0.2;
    
    // é€‰æ‹©å½“å‰å‡½æ•°ç»„åˆ
    sequence_index := (frame / 30) % lengthof function_sequences;
    current_functions := function_sequences[sequence_index];
    
    // åˆ›å»ºæ–°ç”»å¸ƒ
    canvas := mut create_canvas();
    
    // ç»˜åˆ¶åæ ‡è½´
    canvas = draw_axes(canvas);
    
    // ç»˜åˆ¶æ‰€æœ‰é€‰ä¸­çš„å‡½æ•°
    func_index := mut 0;
    while (func_index < lengthof current_functions) {
        func_name := current_functions[func_index];
        func := math_functions.{func_name};
        canvas = plot_function(canvas, func_name, func, time);
        func_index = func_index + 1;
    };
    // æ¸²æŸ“ç”»å¸ƒ
    render_canvas(canvas, frame, current_functions);
    
    // å»¶è¿Ÿ
    delay := mut 0;
    while (delay < 100000) {
        delay = delay + 1;
    };
    
    frame = frame + 1;
};

stdlib.io.println(colorize("æ•°å­¦å¯è§†åŒ–æ¼”ç¤ºç»“æŸ! ğŸ­", "bright_magenta", "bg_black"));
