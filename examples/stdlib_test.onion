@compile "./core/core.onion";
core := ((__lib_root => "./core") -> dyn import("./core/core.onionc"))();
Some := core.Some;
None := core.None;
Option := core.Option;
Result := core.Result;
Ok := core.Ok;
Err := core.Err;
try := core.try;

@required stdlib;
stdlib.io.println("=== Result 测试 ===");
stdlib.io.println(
    try(() -> {
        raise "这是一个错误";
        "这行代码不会被执行";
    }).unwrap_or_else(() -> {
        return "捕获到错误，返回默认值";
    })
);
ok_val := Ok("成功");
err_val := Err("失败");

stdlib.io.println(ok_val.map((x?) -> x + " 处理成功").unwrap());
stdlib.io.println(err_val.map((x?) -> x + " 处理成功").unwrap_or("处理失败"));

stdlib.io.println("=== Option 测试 ===");
some_val := Some(42);
stdlib.io.println(some_val.map((x?) -> x * 2).unwrap());

none_val := None();
stdlib.io.println(none_val.unwrap_or("默认值"));

stdlib.io.println("=== 链式操作测试 ===");
// Result 链式操作
chain_result := Ok(10)
    .map((x?) -> x * 2)
    .map((x?) -> x + 5);
stdlib.io.println("Result 链式:", chain_result.unwrap());

// Option 链式操作
chain_option := Some(5)
    .filter((x?) -> x > 3)
    .map((x?) -> x * 3);
stdlib.io.println("Option 链式:", chain_option.unwrap());

stdlib.io.println("=== 边界情况测试 ===");
// 测试 filter 失败的情况
filtered_none := Some(2)
    .filter((x?) -> x > 5);
stdlib.io.println("Filter 失败:", filtered_none.unwrap_or("无值"));

// 测试 and_then
and_then_result := Some(10)
    .and_then((x?) -> {
        if (x > 5) {
            return Some(x * 2);
        } else {
            return None();
        }
    });
stdlib.io.println("And then:", and_then_result.unwrap());