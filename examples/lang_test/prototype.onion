@required stdlib;
interface := (interface_definition?) -> {
    pointer := mut interface_definition;
    return (
        new => (structure?) -> structure : pointer,
        check => (instance?) -> {
            (valueof instance) is pointer
        },
    )
};

my_interface := interface {
    method1 => () -> stdlib.io.println("Method 1 called"),
    method2 => (arg?) -> stdlib.io.println("Method 2 called with argument:", arg),
    method3 => () -> stdlib.io.println(self.data),
};

my_interface_2 := interface {
    method1 => () -> stdlib.io.println("Method 1 called"),
    method2 => (arg?) -> stdlib.io.println("Method 2 called with argument:", arg),
    method3 => () -> stdlib.io.println(self.data),
};

my_instance := my_interface.new {
    data => "This is some data",
};

my_instance_2 := my_interface_2.new {
    data => "This is some data",
};


stdlib.io.println("Is my_instance an instance of my_interface? ", my_interface.check(my_instance));
stdlib.io.println("Is my_instance an instance of my_interface_2? ", my_interface_2.check(my_instance));
my_instance.method1();
stdlib.io.println("Calling method2 with 'Hello':");
my_instance.method2("Hello");
stdlib.io.println("Calling method3:");
my_instance.method3();

instance_guard_test := (x => my_interface.check) -> {
    stdlib.io.println("Instance guard test passed with:", x.data);
};

instance_guard_test(my_instance); // This should work

// instance_guard_test(my_instance_2); // This should fail, as my_instance_2 is not an instance of my_interface