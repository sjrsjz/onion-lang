@required stdlib;
// 传统函数式写法

f := "x" -> x + 1;

// 我们可以采用下面的方式调用
// Onion 的语法认定 f x 和 f(x) 和 f[x] 是等价的，因为括号和中括号仅仅用来改变运算符优先级

// 传统调用
assert f(1) == 2;
// 也可以使用中括号
assert f[1] == 2;
// 无括号调用
assert f 1 == 2;

// 我们可以给函数的形参加上值约束
guard := "x" -> x > 0;

f := (x => guard) -> x + 1; // 或者 f := ("x" : guard) -> x + 1;
// 这样调用时会检查 x 是否大于 0，如果不大于 0 则会抛出异常
assert f(1) == 2;
// f(0) // 抛出异常

// 或者使用逻辑值表示约束，true表示永远成立，false表示永远不成立
f := (x => true) -> x + 1; // 或者 f := ("x" : true) -> x + 1;

// 这样调用时不会检查 x 的值
assert f(1) == 2;

// 可以用 x? 表示 x => true
f := (x?) -> x + 1;
assert f(1) == 2;

// 我们也可以让函数的形参是一个元组
f := ("x", "y") -> x + y;

assert f(1, 2) == 3;

// 由于 f x 和 f(x) 是等价的，所以我们也可以使用下面的方式调用
// 调用时，VM会解包元组挨个传递给对应槽位
// 注意：(x?,) -> {} 和 (x?) -> {} 是不同的，前者是一个元组，后者是一个单值参数，后者不会对传入的值进行解包。这意味着向要求为单元素元组的函数传递一个单值参数时，VM会立即报错，因为它无法解包这个单值参数，也就是说调用时必须传入一个单值元组
packaged := (1, 2);
assert f(packaged) == 3;
assert f packaged == 3;

// 我们也可以给元组形式的形参加上值约束
f := (x => guard, y => guard) -> x + y;

assert f(1, 2) == 3;


// 可以用 keyof 获得函数的形参列表
stdlib.io.println("Function parameters:", keyof f);