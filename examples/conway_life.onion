// Conway's Game of Life
@required 'stdlib';
@include "std/tui_colors.onion";

width := 60;
height := 40;
generations := 1000;

// Simple pseudo-random number generator (Linear Congruential Generator)
rand_seed := mut 12345;
random := () -> {
    rand_seed = (rand_seed * 1103515245 + 12345) % 2147483648;
    return rand_seed / 2147483648.0;
};

// 创建初始网格
create_grid := (w?, h?) -> {
    grid := mut ();
    y := mut 0;
    while (y < h) {
        row := mut ();
        x := mut 0;
        while (x < w) {
            // Randomly initialize cells (about 30% alive)
            alive := mut (random() < 0.3);  // Make boolean mutable
            row = row + (alive,);
            x = x + 1;
        };
        grid = grid + (row,);
        y = y + 1;
    };
    return grid;
};

// Count number of neighbors
count_neighbors := (grid?, x?, y?, w?, h?) -> {
    count := mut 0;
    dy := mut (-1);
    while (dy <= 1) {
        dx := mut (-1);
        while (dx <= 1) {
            if (not (dx == 0 and dy == 0)) {
                nx := x + dx;
                ny := y + dy;
                if (nx >= 0 and nx < w and ny >= 0 and ny < h) {
                    if (grid[ny][nx]) {
                        count = count + 1;
                    };
                };
            };
            dx = dx + 1;
        };
        dy = dy + 1;
    };
    return count;
};

// Update grid to buffer
update_grid := (current_grid?, buffer_grid?, w?, h?) -> {
    y := mut 0;
    while (y < h) {
        x := mut 0;
        while (x < w) {
            neighbors := count_neighbors(current_grid, x, y, w, h);
            current := current_grid[y][x];
            
            // Conway's Game of Life rules
            new_cell := if (current) {
                // Live cell: survives with 2-3 neighbors, otherwise dies
                neighbors == 2 or neighbors == 3
            } else {
                // Dead cell: revives with exactly 3 neighbors
                neighbors == 3
            };
            
            buffer_grid[y][x] = new_cell;
            x = x + 1;
        };
        y = y + 1;
    };
};

// Swap buffer contents
swap_buffers := (grid1?, grid2?, w?, h?) -> {
    y := mut 0;
    while (y < h) {
        x := mut 0;
        while (x < w) {
            temp := grid1[y][x];  // Make temp variable mutable
            grid1[y][x] = grid2[y][x];
            grid2[y][x] = temp;
            x = x + 1;
        };
        y = y + 1;
    };
};

// Double-buffered rendering - prebuild full display text
render_frame := (grid?, w?, h?, generation?) -> {
    // Create text buffer
    display_buffer := mut "";
    
    // Clear screen and reset cursor
    display_buffer = display_buffer + "\u001b[2J\u001b[H";
    
    // Build title
    title := "🔬 Conway's Game of Life [Generation " + stdlib.types.to_string(generation) + "] 🧬";
    display_buffer = display_buffer + colorize(title, "bright_cyan", "bg_black") + "\n";
    
    // Count number of live cells
    alive_count := mut 0;
    y := mut 0;
    while (y < h) {
        x := mut 0;
        while (x < w) {
            if (grid[y][x]) {
                alive_count = alive_count + 1;
            };
            x = x + 1;
        };
        y = y + 1;
    };
    
    // Build info line
    info := "Live cells: " + stdlib.types.to_string(alive_count) + " | Double-buffered rendering | Size: " + stdlib.types.to_string(w) + "x" + stdlib.types.to_string(h);
    display_buffer = display_buffer + colorize(info, "bright_yellow", "bg_black") + "\n";
    
    // Build top border
    border_top := mut "┌";
    x := mut 0;
    while (x < w * 2) {
        border_top = border_top + "─";
        x = x + 1;
    };
    border_top = border_top + "┐";
    display_buffer = display_buffer + colorize(border_top, "bright_white", "bg_black") + "\n";
    
    // Build grid content
    y = 0;
    while (y < h) {
        row_text := mut "│";
        x = 0;
        while (x < w) {
            if (grid[y][x]) {
                row_text = row_text + colorize("██", "bright_green", "bg_black");
            } else {
                row_text = row_text + "  ";
            };
            x = x + 1;
        };
        row_text = row_text + colorize("│", "bright_white", "bg_black");
        display_buffer = display_buffer + row_text + "\n";
        y = y + 1;
    };
    
    // Build bottom border
    border_bottom := mut "└";
    x = 0;
    while (x < w * 2) {
        border_bottom = border_bottom + "─";
        x = x + 1;
    };
    border_bottom = border_bottom + "┘";
    display_buffer = display_buffer + colorize(border_bottom, "bright_white", "bg_black") + "\n";
    
    // Build rules info
    rules := "Rules: Live cell survives with 2-3 neighbors | Dead cell revives with 3 neighbors | Otherwise dies";
    display_buffer = display_buffer + colorize(rules, "bright_cyan", "bg_black") + "\n";
    
    // Output the full display buffer at once
    stdlib.io.print(display_buffer);
};

// Main loop - using double-buffering and pre-rendering
current_grid := mut create_grid(width, height);
buffer_grid := mut create_grid(width, height);  // Create buffer
generation := mut 0;

// Clear buffer (initialize to false)
y := mut 0;
while (y < height) {
    x := mut 0;
    while (x < width) {
        buffer_grid[y][x] = mut false;  // Make boolean mutable
        x = x + 1;
    };
    y = y + 1;
};

startup_msg := colorize("🎮 Conway's Game of Life started! Using double-buffering + pre-rendering", "bright_magenta", "bg_black");
stdlib.io.println(startup_msg);
stdlib.io.println(colorize("Press Ctrl+C to exit", "bright_yellow", "bg_black"));

while (generation < generations) {
    // Prebuild full frame and output at once
    render_frame(current_grid, width, height, generation);
    
    // Pause to let user see the animation
    stdlib.time.sleep_millis(20);
    
    // Calculate next generation to buffer
    update_grid(current_grid, buffer_grid, width, height);
    
    // Swap buffers (core of double-buffering)
    swap_buffers(current_grid, buffer_grid, width, height);
    
    generation = generation + 1;
};

stdlib.io.println(colorize("🎭 Game of Life ended! Double-buffered + pre-rendering demo complete!", "bright_yellow", "bg_black"));
stdlib.io.println(colorize("Thank you for experiencing smooth rendering technology!", "bright_green", "bg_black"));
