Result := mut undefined;


Ok := (v?) -> Result(true : v);
Err := (v?) -> Result(false : v);


Result = (result_pair?) -> ( // use `=` to redefine Result
    result_pair : {
        is_ok => () -> keyof keyof self,
        is_err => () -> not keyof keyof self,
        map => (f?) -> {
            if (self.is_ok()) {
                return Ok(f(valueof keyof self));
            } else {
                return Result(keyof self);
            }
        },
        map_err => (f?) -> {
            if (self.is_err()) {
                return Err(f(valueof keyof self));
            } else {
                return Result(keyof self);
            }
        },
        unwrap => () -> {
            if (self.is_ok()) {
                return valueof keyof self;
            } else {
                raise Err("Result is an error");
            }
        },
        unwrap_or => (default?) -> {
            if (self.is_ok()) {
                return valueof keyof self;
            } else {
                return default;
            }
        },
        unwrap_or_else => (f?) -> {
            if (self.is_ok()) {
                return valueof keyof self;
            } else {
                return f();
            }
        },
        unwrap_err => () -> {
            if (self.is_err()) {
                return valueof keyof self;
            } else {
                raise Err("Result is not an error");
            }
        },
    }
);


try := (f?) -> {
    Result(sync f())
};

Option := mut undefined;

Some := (v?) -> Option(true : v);
None := () -> Option(false : undefined);

Option := (option_pair?) -> (
    option_pair : {
        is_some => () -> keyof keyof self,
        is_none => () -> not keyof keyof self,
        map => (f?) -> {
            if (self.is_some()) {
                return Some(f(valueof keyof self));
            } else {
                return None();
            }
        },
        filter => (predicate?) -> {
            if (self.is_some() and predicate(valueof keyof self)) {
                return Option(keyof self);
            } else {
                return None();
            }
        },
        unwrap => () -> {
            if (self.is_some()) {
                return valueof keyof self;
            } else {
                raise Err("Option is None");
            }
        },
        unwrap_or => (default?) -> {
            if (self.is_some()) {
                return valueof keyof self;
            } else {
                return default;
            }
        },
        unwrap_or_else => (f?) -> {
            if (self.is_some()) {
                return valueof keyof self;
            } else {
                return f();
            }
        },
        and_then => (f?) -> {
            if (self.is_some()) {
                return f(valueof keyof self);
            } else {
                return None();
            }
        },
        or_else => (f?) -> {
            if (self.is_some()) {
                return Option(keyof self);
            } else {
                return f();
            }
        },
    }
);


@compile "./prototype.onion";
@required __lib_root;
prototype := (__lib_root!) -> dyn import(__lib_root + "/prototype.onionc");

return {
    Result!,
    Ok!,
    Err!,
    try!,
    Option!,
    Some!,
    None!,
    prototype!,
}