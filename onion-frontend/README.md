# ğŸ§… Onion Frontend

The compilation frontend for the Onion programming language. This package handles lexical analysis, parsing, semantic analysis, and intermediate representation generation.

## ğŸ“š Overview

The `onion-frontend` package is responsible for transforming Onion source code into intermediate representation (IR) that can be executed by the Onion Virtual Machine. It implements a complete compilation pipeline from source text to executable bytecode.

## ğŸ—ï¸ Architecture

```
Source Code â†’ Lexer â†’ Parser â†’ AST â†’ Analyzer â†’ IR Generator â†’ IR/Bytecode
```

### Components

- **Lexer** (`parser/lexer.rs`) - Tokenizes source code into a stream of tokens
- **Parser** (`parser/ast.rs`) - Builds Abstract Syntax Tree (AST) from tokens
- **Analyzer** (`parser/analyzer.rs`) - Performs semantic analysis and error checking
- **IR Generator** (`ir_generator/`) - Generates intermediate representation from AST
- **Compiler** (`compile.rs`) - Orchestrates the entire compilation process

## âœ¨ Features

- ğŸ” **Lexical Analysis** - Complete tokenization with support for Unicode
- ğŸŒ³ **AST Generation** - Builds structured representation of source code
- ğŸ” **Semantic Analysis** - Type checking and error detection
- ğŸ“¦ **IR Generation** - Produces optimized intermediate representation
- ğŸš€ **Bytecode Compilation** - Generates executable bytecode for the VM
- ğŸ”§ **Error Reporting** - Rich error messages with source location information

## ğŸš€ Usage

### Basic Compilation

```rust
use onion_frontend::compile::{build_code, compile_to_bytecode};
use onion_frontend::dir_stack::DirStack;

// Compile to IR
let mut dir_stack = DirStack::new();
let source = r#"
    @required stdlib;
    main := () -> {
        stdlib.io.println("Hello, World!");
    };
    main();
"#;

let ir_package = build_code(source, &mut dir_stack)?;

// Compile to bytecode
let bytecode = compile_to_bytecode(source, &mut dir_stack)?;
```

### Advanced Usage

```rust
use onion_frontend::parser::lexer;
use onion_frontend::parser::ast::{ast_token_stream, build_ast};
use onion_frontend::parser::analyzer::analyze_ast;

// Manual compilation pipeline
let tokens = lexer::tokenize(source);
let tokens = lexer::reject_comment(&tokens);
let gathered = ast_token_stream::from_stream(&tokens);
let ast = build_ast(gathered)?;
let analysis = analyze_ast(&ast, None, &mut dir_stack);
```

## ğŸ“‹ API Reference

### Main Functions

- `build_code(code: &str, dir_stack: &mut DirStack) -> Result<IRPackage, String>`
  - Compiles source code to intermediate representation
  
- `compile_to_bytecode(code: &str, dir_stack: &mut DirStack) -> Result<VMInstructionPackage, String>`
  - Compiles source code directly to bytecode

### Key Types

- `IRPackage` - Contains intermediate representation and debug information
- `VMInstructionPackage` - Executable bytecode package
- `DirStack` - Manages file paths and module resolution

## ğŸ”§ Dependencies

- `onion-vm` - Virtual machine types and instruction definitions
- `colored` - Terminal color output for error messages
- `regex` - Regular expression support for lexical analysis
- `unicode-segmentation` - Unicode-aware string processing
- `base64` - Encoding support for bytecode serialization

## ğŸ—ï¸ Module Structure

```
onion-frontend/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ lib.rs              # Public API exports
â”‚   â”œâ”€â”€ compile.rs          # Main compilation orchestration
â”‚   â”œâ”€â”€ dir_stack.rs        # Directory and path management
â”‚   â”œâ”€â”€ parser/             # Lexical and syntactic analysis
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ lexer.rs        # Tokenization
â”‚   â”‚   â”œâ”€â”€ ast.rs          # AST construction
â”‚   â”‚   â””â”€â”€ analyzer.rs     # Semantic analysis
â”‚   â””â”€â”€ ir_generator/       # Intermediate representation
â”‚       â”œâ”€â”€ mod.rs
â”‚       â””â”€â”€ ir_generator.rs # IR generation logic
â””â”€â”€ Cargo.toml
```

## ğŸ¯ Design Goals

1. **Correctness** - Comprehensive error checking and validation
2. **Performance** - Efficient compilation with minimal overhead
3. **Extensibility** - Modular design for easy feature additions
4. **Developer Experience** - Clear error messages and debugging support

## ğŸ¤ Integration

This package is designed to work seamlessly with:

- **onion-vm** - Executes the generated bytecode
- **Language Server** - Provides IDE support through compilation services
- **CLI Tools** - Powers the `onion compile` command

## ğŸ“„ License

This package is part of the Onion programming language project and is licensed under the MIT License.
