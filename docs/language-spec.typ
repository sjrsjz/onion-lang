#import "@preview/zebraw:0.5.5": *
#show raw: zebraw
#show raw.where(block: false): it => box(fill: luma(230), outset: (x: 0.25em, y: 0.35em), radius: 2pt, it)
#set text(font: ("JetBrains Mono", "Microsoft YaHei UI"))
#set heading(numbering: "1.")

= Onion 语言参考文档

== 核心理念

Onion 是一种以表达式为中心的现代函数式编程语言。它的设计哲学强调代码的表达力、安全性和灵活性。在 Onion 中，几乎所有代码结构都是表达式，每个表达式都会产生一个值。

其核心特性包括：
- *表达式导向*：代码由表达式和表达式组构成，分号 `;` 用于分隔顺序执行的子表达式。
- *作用域规则*：没有全局作用域，只有函数作用域和由 `{}` 创建的块级作用域，变量生命周期清晰可控。
- *强大的元编程*：支持在编译时通过宏和抽象语法树（AST）操作来生成和修改代码。
- *显式可变性*：默认所有变量不可变，通过 `mut` 关键字显式创建可变引用，增强代码的安全性。

== 语法基础

=== 原子表达式与代码分组

原子表达式是 Onion 语言语法分析中的基本单元，它将输入的 token 流分组为可独立处理的语法单元。

*原子表达式组* 是满足以下条件的 token 序列：

1. *括号平衡*：组内所有的 `{}`, `[]`, `()` 都完全匹配。
2. *最小完整性*：从当前位置开始，当所有括号栈为空时结束。
3. *独立性*：每个组可以独立进行语法分析，不依赖其他组。

在后续语法描述中，我们使用以下术语：
- `<atom>` - 表示一个原子表达式组
- `<atoms>` - 表示多个原子表达式组的序列
- `<atom-expr>` - 表示原子表达式（同 `<atom>`）

#figure(
  caption: [
    原子表达式分组示例
  ],
  raw(
    lang: "onion",
    block: true,
    "
// 输入表达式
a + (b * c) + {x: y}

// 分组结果
[a]        // 组1: 单个标识符
[+]        // 组2: 运算符
[(b * c)]  // 组3: 完整的括号表达式
[+]        // 组4: 运算符
[{x: y}]   // 组5: 完整的对象字面量
[]   // 组6: 完整的数组字面量
",
  ),
)

=== 表达式序列

分号 `;` 用于连接多个表达式，形成一个顺序执行的表达式组。整个组的值是最后一个子表达式的值。如果最后一个子表达式为空（即以 `;` 结尾），则整个组的值为 `()`（空元组）。

```onion
x := (
  stdlib.io.println("第一步"); // 执行
  1 + 1;                     // 执行并计算出 2
  42                         // 最终 x 的值为 42
);

y := (
  stdlib.io.println("另一步");
  x + 1; // 执行，但因为后面有分号，其结果被丢弃
); // y 的值为 ()
```

== 类型系统

Onion 拥有一个简洁而强大的动态类型系统。所有类型的值在内部都由一个统一的结构表示。以下是其在 Rust 中的核心实现：

```rust
pub enum OnionObject {
    // immutable basic types
    Integer(i64),
    Float(f64),
    String(Arc<String>),
    Bytes(Arc<Vec<u8>>),
    Boolean(bool),
    Range(i64, i64),
    Null,
    Undefined(Option<Arc<String>>),
    InstructionPackage(Arc<VMInstructionPackage>),

    Tuple(Arc<OnionTuple>),
    Pair(Arc<OnionPair>),
    LazySet(Arc<OnionLazySet>),
    Lambda((Arc<OnionLambdaDefinition>, Arc<OnionObject>)),
    Custom(Arc<dyn OnionObjectExt>),

    Mut(GCArcWeak<OnionObjectCell>),
}
```

=== 内置类型

#table(
  columns: (1fr, 1fr, 1fr),
  align: (left, left, left),
  [*类型*], [*语法示例*], [*描述*],
  [Integer], [`42`, `-100`, `0xFF`], [64位有符号整数。],
  [Float], [`3.14`, `-0.01`, `1.5e2`], [64位双精度浮点数。],
  [String], [`"abc"`, `'abc'`, `"""line1\nline2"""`], [UTF-8 编码的字符串。支持多种字面量形式。],
  [Bytes], [`$"SGVsbG8="`], [原始字节数组，字面量使用 Base64 编码。],
  [Boolean], [`true`, `false`], [布尔逻辑值。],
  [Range], [`1..10`], [表示一个包含起始和结束的整数范围。],
  [Null], [`null`], [表示“无值”或空。],
  [Undefined], [`undefined`], [表示未初始化或无效状态的值。],
  [Tuple], [`(1, "a", true)`, `42,`], [有序的值的集合。单元素元组需尾随逗号。],
  [Pair], [`"name": "Alice"`, `age => 30`], [键值对。`=>` 会将裸标识符键转为字符串。],
  [LazySet], [`(1..100) | (x?) -> x % 2 == 0`], [懒加载集合，仅在访问时过滤元素。],
  [Lambda], [`(x?) -> x + 1`], [匿名函数或闭包。],
  [Mut], [`mut 42`, `mut "hello"`], [指向一个堆上可变槽位的引用。],
  [InstructionPackage], [`import "./module.onionc"`], [已编译的模块字节码。],
)

== 变量与作用域

=== 作用域规则

- *无全局作用域*：所有变量和函数都必须在特定的作用域内定义。
- *函数作用域*：每次函数调用都会创建一个新的作用域。
- *块级作用域*：使用 `{}` 包围的代码会创建一个新的块级作用域。变量在外部不可见。

=== 变量定义

使用 `:=` 操作符在当前作用域内定义一个新变量。若已存在同名变量，`:=` 会*遮蔽 (shadow)* 旧变量。

```onion
x := 42;
x := "hello"; // x 现在被遮蔽，新类型是 String
```

=== 可变性 (`mut`, `=`, `const`)

在 Onion 语言中，变量默认是不可变的。如果需要创建一个“可变”变量，可以使用 `mut` 关键字。

`mut` 关键字表示*将值装载到堆上（受GC控制管理生命周期）并获得可变引用*。`=` 赋值操作符用于替换该引用所指向的值。

如果要从可变引用中获得一个不可变的值，可以使用 `const`。该操作会获取 `mut` 引用当前指向的值的一个不可变共享（对于基础类型是拷贝，对于复合类型是共享引用），而不会修改原始的 `mut` 引用。

```onion
// 定义一个可变变量
x := mut 42;
// 替换可变变量的值
x = 100;

// 定义一个不可变变量，默认不可变
y := 50;
// y = 60; // 错误: Cannot assign to immutable variable

// const 用于获取不可变值
z := const x; // z 的值是 100，但 z 本身是不可变的
```

元组自身的可变性与其元素的可变性是独立的：
```onion
// x 是一个指向堆上元组的 mut 引用，可以被替换
x := mut (1, 2, 3);
x = (10, 2, 3); // 允许，替换了整个元组
// x = 10; // 错误！元组内的元素默认是不可变的

// y 是一个不可变的元组，但其第一个元素是 mut 引用
y := (mut 1, 2, 3);
y = 10; // 允许，修改了第一个元素引用的值
// y = (10, 2, 3); // 错误！y 本身是不可变的，不能被替换
```

==== 幂等律
Onion VM 在对象设计上严格遵循不可变性。为了保证操作的一致性和安全性，`mut` 和 `const` 遵循幂等律：

- `mut (mut x)` 等价于 `mut x`
- `const (const x)` 等价于 `const x`

这意味着：
- *`mut` 操作符*: 如果接收的值已经是 `mut` 引用，则直接返回该引用。如果值是不可变的，则会创建一个新的 `mut` 引用指向该值的共享。
- *`const` 操作符*: 如果接收的值已经是不可变的，则直接返回该值。如果是 `mut` 引用，则返回该引用所指向的值的不可变共享。

这种设计通过内部的 `Arc`（原子引用计数）高效地共享数据，避免了不必要的数据复制。应当将 `mut` 理解为一个指向可替换堆对象的、地址本身不可变的*万能容器*。

== 数据结构

=== 元组 (Tuple)
元组是值的有序集合，其定义和 Python 类似。

```onion
my_tuple := (1, "hello", true);
single_element_tuple := (42,); // 注意尾部的逗号
empty_tuple := ();
```

=== 键值对 (Pair) 与原型对象
键值对是 Onion 构建复杂对象的基石。当键值对和元组合并使用时，可以形成类似字典或对象的结构。

```onion
person := (
  "name": "Alice",
  "age": 30
);

name := person.name; // 结果: "Alice"```

通过将一个对象链接到另一个对象 (`:` 运算符)，Onion 实现了*原型继承*。

```onion
// 定义一个原型
greeter_prototype := {
  greet => () -> "Hello, " + self.name
};

// 创建一个实例，并将其原型链指向 greeter_prototype
user := {
  name => "Bob"
} : greeter_prototype;

// 调用方法时，`self` 会被绑定到 `user` 对象
greeting := user.greet(); // 结果: "Hello, Bob"
```

== 函数

=== 定义与调用
函数是 Onion 的一等公民。

```onion
// `?` 表示接受任意类型
add_any := (x?, y?) -> x + y;

// 调用方式
add_any(1, 2);    // 结果: 3

// 下述调用方式等价
// 注意 Onion 的括号仅仅用于分组，而不是函数调用的必需部分
// 元组解包是 VM 的一部分，允许直接传递元组
tuple := (1, 2);
add_any tuple;     // 无括号调用，等价
add_any (tuple); 
add_any (1, 2);   // 传递元组，自动解包
```

=== 闭包与变量捕获
函数可以捕获其定义时所在作用域的变量，形成闭包。编译器会自动分析并隐式捕获这些变量。

```onion
multiplier := (factor?) -> {
  // 返回的新函数捕获了 `factor`
  return (n?) -> n * factor;
};

double := multiplier(2);
double(5); // 结果: 10
```

=== 特殊变量：`self` 和 `this`

- *`self`*: 在通过 `.` 操作符调用方法时，`self` 被绑定到点左侧的对象实例。它代表了方法调用的“上下文”。
- *`this`*: `this` 总是指向被调用的函数对象本身。这对于递归或访问函数自身的属性非常有用。

== 运算符

=== 优先级改变
可以使用 `()`, `[]` 或 `{}` 来改变运算符的优先级。`()` 和 `[]` 在改变优先级上语义相同。`{}` 通常用于表示新的作用域或者阻止前端自动转换表达式类型。

```onion
(2 + 3) * 4      // 结果: 20
[2 + 3] * 4      // 结果: 20
dict.{key}       // 通过变量 key 而非字面量访问，和 dict.key 不同
```

=== 算术运算符
#table(
  columns: (20%, 20%, 60%),
  [*运算符*], [*名称*], [*支持的操作*],
  [`+`], [加法], [`Integer`, `Float` (相加), `String`, `Bytes`, `Tuple` (连接), `Range` (平移)],
  [`-`], [减法], [`Integer`, `Float`],
  [`*`], [乘法], [`Integer`, `Float`],
  [`/`], [除法], [`Integer` (整除), `Float`],
  [`%`], [取模], [`Integer`, `Float`],
  [`**`], [幂], [`Integer`, `Float`],
)

*加法 `+` 的类型组合细节:*
- `Integer + Integer` -> `Integer`
- `String + String` -> `String` (连接)
- `Tuple + Tuple` -> `Tuple` (连接)

=== 位运算符
#table(
  columns: (20%, 20%, 30%, 30%),
  [*运算符*], [*名称*], [*`Boolean` 操作*], [*`Integer` 操作*],
  [`and`], [与], [逻辑与], [按位与],
  [`or`], [或], [逻辑或], [按位或],
  [`xor`], [异或], [(不支持)], [按位异或],
  [`not`], [非], [逻辑非], [按位取反],
  [`<<`], [左移], [(不支持)], [按位左移],
  [`>>`], [右移], [(不支持)], [按位右移],
)

=== 一元运算符
#table(
  columns: (20%, 20%, 60%),
  [*运算符*], [*名称*], [*描述*],
  [`-`], [负号], [数值取负。],
  [`+`], [正号], [数值取绝对值。],
  [`not`], [逻辑/按位非], [对 `Boolean` 取逻辑反，对 `Integer` 按位取反。],
)

=== 比较运算符
`==`, `!=`, `<`, `>`, `<=`, `>=` 用于比较。数值类型支持跨类型比较（如 `3.0 == 3`）。

=== 类型转换规则
当不同数值类型参与运算时，遵循以下规则：
1. `Integer` 与 `Float` 运算时，`Integer` 自动转换为 `Float`。
2. 结果类型为参与运算的最宽类型 (`Float` > `Integer`)。
3. 字符串和字节数组不参与自动类型转换。

=== 错误处理
运算符在运行时可能产生错误，例如：
- `Division by zero` - 除零错误。
- `InvalidOperation` - 不支持的运算类型组合。

可以使用 `sync f`（同步池化调度） 来修饰一个函数，使其在运行时捕获这些错误并返回一个 `pair`，其中第一个元素是表示是否成功的布尔值，第二个元素是结果或错误信息。